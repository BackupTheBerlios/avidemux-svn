//
/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#define Ui_Dialog Ui_prefDialog
#include "ui_pref.h"
#undef Ui_Dialog

#include "default.h"
#include "ADM_toolkit/filesel.h"

# include "prefs.h"
#include "ADM_audiodevice/audio_out.h"

#include "ADM_assert.h"
#include "GUI_render.h"
#include "ADM_osSupport/ADM_cpuCap.h"
#include "ADM_toolkit/toolkit.hxx"

static void setpp(void);



extern void 		AVDM_audioPref( void );

typedef struct stVideoDevice
{
        ADM_RENDER_TYPE type;
        char            *name;

}stVideoDevice;

static stVideoDevice myVideoDevice[]
={
        {RENDER_GTK,"QT (no accel)"},
#ifdef USE_XV
        {RENDER_XV,"Xvideo accel (best)"},
#endif
#ifdef USE_SDL
        {RENDER_SDL,"SDL accel"},
#endif

};

uint8_t DIA_Preferences(void);


uint8_t DIA_Preferences(void)
{
uint8_t ret=0;
int r;
char *str;
const char *nullstring="";
#ifdef HAVE_AUDIO
AUDIO_DEVICE olddevice,newdevice;
#endif
uint32_t	lavcodec_mpeg=0;
uint32_t        use_odml=0;
uint32_t	autosplit=0;
uint32_t k;
unsigned int renderI;
ADM_RENDER_TYPE render;
uint32_t useTray=0;
uint32_t useMaster=0;
uint32_t useAutoIndex=0;
uint32_t useSwap=0;
uint32_t useNuv=0;
uint32_t mthreads=0;	
uint32_t downmix;
uint32_t mpeg_no_limit=0;

        Ui_prefDialog dialog;
        
        dialog.setupUi(NULL);

        if(!prefs->get(FEATURE_USE_SYSTRAY,&useTray)) useTray=0;
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonSystray)),useTray);
        
        if(!prefs->get(FEATURE_MPEG_NO_LIMIT,&mpeg_no_limit)) mpeg_no_limit=0;
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonLimit)),mpeg_no_limit);
        

//****************************	
#if 0
#define SET_CPU(x,y) gtk_widget_set_sensitive(WID(check##x),0); \
        if(CpuCaps::has##y()) gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(check##x)),1);
#else
        #define SET_CPU(x,y)
#endif
        SET_CPU(MMX,MMX);
        SET_CPU(MMXEXT,MMXEXT);
        SET_CPU(3DNOW,3DNOW);
        SET_CPU(SSE,SSE);
        SET_CPU(SSE2,SSE2);
        //gtk_widget_set_sensitive( (WID(checkAltivec)),0);
//         gtk_widget_set_sensitive( (WID(checkbuttonReuseLog)),0);
//****************************
#ifdef HAVE_AUDIO
	olddevice=newdevice=AVDM_getCurrentDevice();
#endif
	
	#define CONNECT(A,B)  gtk_signal_connect (GTK_OBJECT(lookup_widget(dialog,#A)), "clicked", \
		      GTK_SIGNAL_FUNC (B), (void *) NULL);

	
#define SPIN_GET(x,y) {x= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(y))) ;}
#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(y)),(gfloat)x) ;}

	// Alsa
        if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &str) != RC_OK )
               str = ADM_strdup("plughw:0,0");
//         gtk_write_entry_string(WID(entryALSADevice), str);
        ADM_dealloc(str);
	// Multithreads
	if(!prefs->get(FEATURE_MULTI_THREAD, &mthreads))
	{
		mthreads=0;		
	}
//         SPIN_SET(mthreads,spinbuttonThread);
	// VCD/SVCD split point		
	if(!prefs->get(SETTINGS_MPEGSPLIT, &autosplit))
	{
		autosplit=690;		
	}
	// Fill entry
//          SPIN_SET(autosplit,spinbuttonMPEGSplit);
        		
	if(!prefs->get(FEATURE_USE_LAVCODEC_MPEG, &lavcodec_mpeg))
	{
		lavcodec_mpeg=0;		
	}		
// 	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonLibavcodec)),
// 			lavcodec_mpeg);
        
        // Open DML (Gmv)
        if(!prefs->get(FEATURE_USE_ODML, &use_odml))
        {
          use_odml=0;                
        }               
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonOpenDML)),
//                                       use_odml);

        if(!prefs->get(FEATURE_AUDIOBAR_USES_MASTER, &useMaster))
                useMaster=0;
        
//         if(useMaster) RADIO_SET(radiobuttonMaster,1);
//                 else RADIO_SET(radiobuttonPCM,1);


        if(!prefs->get(FEATURE_TRYAUTOIDX, &useAutoIndex))
                useAutoIndex=0;
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonAutoindex)),useAutoIndex);

        
        if(!prefs->get(FEATURE_SWAP_IF_A_GREATER_THAN_B, &useSwap))
                useSwap=0;
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonSwapAB)),useSwap);


        if(!prefs->get(FEATURE_DISABLE_NUV_RESYNC, &useNuv))
                useNuv=0;
//         gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(checkbuttonNuvResync)),useNuv);
        // _____________Message level_____________
        //________________________________________
//         GtkComboBox     *combo_box;
        unsigned int msg=2;
        prefs->get(MESSAGE_LEVEL,&msg);
//         combo_box=GTK_COMBO_BOX(WID(comboboxMessageLevel));
//         gtk_combo_box_set_active(combo_box,msg);
        
        // ___________Video accel device ______________________________________________
        
        
//         combo_box=GTK_COMBO_BOX(WID(comboboxVideoOutput));
        int vd=0;
        if(prefs->get(DEVICE_VIDEODEVICE,&renderI)!=RC_OK)
        {       
                render=RENDER_GTK;
        }else
        {
                render=(ADM_RENDER_TYPE)renderI;
        }
        for(uint32_t i=0;i<sizeof(myVideoDevice)/sizeof(stVideoDevice);i++)
        {
                if(myVideoDevice[i].type==render)
                        {
                                vd=i;
                        }
//                 gtk_combo_box_append_text      (combo_box,myVideoDevice[i].name);
        }               
//         gtk_combo_box_set_active(combo_box,vd);
#ifdef HAVE_AUDIO
        // ___________ Downmixing ______________________________________________
        if(prefs->get(DOWNMIXING_PROLOGIC,&downmix)!=RC_OK)
        {       
            downmix=0;
        }
//         combo_box=GTK_COMBO_BOX(WID(comboboxDownMix));
//         gtk_combo_box_set_active(combo_box,downmix);
	// ___________ Audio accel device ______________________________________________
        
//         combo_box=GTK_COMBO_BOX(WID(comboboxAudioOutput));
        for(uint32_t i=0;i<sizeof(audioDeviceList)/sizeof(DEVICELIST);i++)
        {
                if(audioDeviceList[i].id==olddevice)
                {
                        k=i;
                }
//                 gtk_combo_box_append_text      (combo_box,audioDeviceList[i].name);
        }
//         gtk_combo_box_set_active(combo_box,k);
#endif
        //______________________________________________________
        // Callback for button
//         gtk_signal_connect(GTK_OBJECT(WID(buttonPostprocLevel)), "clicked",GTK_SIGNAL_FUNC(setpp),   NULL);
	 // __________ run _____________________
//        dialog.exec();
// 	gtk_dialog_run(GTK_DIALOG(dialog));
	{
		ret=1;
#ifdef HAVE_AUDIO
		// Limit
                mpeg_no_limit=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonLimit)));
		prefs->set(FEATURE_MPEG_NO_LIMIT, mpeg_no_limit);
                // Get downmix
//                 k=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(comboboxDownMix)));
                prefs->set(DOWNMIXING_PROLOGIC,k);
                
		// Get device
// 		k=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(comboboxAudioOutput)));
		newdevice=audioDeviceList[k].id;
		if(newdevice!=olddevice)
		{
			AVDM_switch(newdevice);
		}
                //
                //alsa device
//                 str=gtk_editable_get_chars(GTK_EDITABLE (WID(entryALSADevice)), 0, -1);
                if(str)
                        prefs->set(DEVICE_AUDIO_ALSA_DEVICE, str);
#endif
                uint32_t s;
//                 s=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(comboboxMessageLevel)));
                prefs->set(MESSAGE_LEVEL,s);
                // video device

//                 k=gtk_combo_box_get_active(GTK_COMBO_BOX(WID(comboboxVideoOutput)));
                render=myVideoDevice[k].type;
                renderI=(int)render;
                prefs->set(DEVICE_VIDEODEVICE,renderI);
        
                //**************
//                 useTray=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonSystray)));
                prefs->set(FEATURE_USE_SYSTRAY,useTray);
                
                //*************
//                 if(RADIO_GET(radiobuttonMaster))
//                         prefs->set(FEATURE_AUDIOBAR_USES_MASTER,(uint32_t) 1);
//                 else
//                         prefs->set(FEATURE_AUDIOBAR_USES_MASTER,(uint32_t) 0);

                ///*********
// 		lavcodec_mpeg=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonLibavcodec)));
		prefs->set(FEATURE_USE_LAVCODEC_MPEG, lavcodec_mpeg);
                
//                 use_odml=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonOpenDML)));
                prefs->set(FEATURE_USE_ODML, use_odml);
                
//                 SPIN_GET(autosplit,spinbuttonMPEGSplit);
		prefs->set(SETTINGS_MPEGSPLIT, autosplit);
                
                //
//                 SPIN_GET(mthreads,spinbuttonThread);
                if(mthreads<2) mthreads=0;
                prefs->set(FEATURE_MULTI_THREAD, mthreads);
                //

//                 useAutoIndex=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonAutoindex)));
                prefs->set(FEATURE_TRYAUTOIDX, useAutoIndex);

//                 useSwap=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonSwapAB)));
                prefs->set(FEATURE_SWAP_IF_A_GREATER_THAN_B, useSwap);

//                 useNuv=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(checkbuttonNuvResync)));
                prefs->set(FEATURE_DISABLE_NUV_RESYNC, useNuv);
		
	}
       
	return ret;
}
extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
void setpp(void)
{
        uint32_t type,strength,uv=0;

        if(!prefs->get(DEFAULT_POSTPROC_TYPE,&type)) type=3;
        if(!prefs->get(DEFAULT_POSTPROC_VALUE,&strength)) strength=3;
        if( DIA_getMPParams( &type,&strength,&uv))
        {
                prefs->set(DEFAULT_POSTPROC_TYPE,type);
                prefs->set(DEFAULT_POSTPROC_VALUE,strength);

        }
//	video_body->setPostProc(type, strength, uv);
}
//EOF

