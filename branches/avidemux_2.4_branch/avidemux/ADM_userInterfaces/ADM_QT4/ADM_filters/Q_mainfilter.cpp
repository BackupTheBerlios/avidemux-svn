//
/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


#define Ui_Dialog Ui_mainFilterDialog
#include "ui_mainfilter.h"
#undef Ui_Dialog
#include "QStringListModel" 
#include "default.h"
#include "ADM_toolkit/filesel.h"

# include "prefs.h"
#include "ADM_audiodevice/audio_out.h"
#include "ADM_audio/ADM_audiodef.h"

#include "ADM_assert.h"
#include "GUI_render.h"
#include "ADM_osSupport/ADM_cpuCap.h"
#include "ADM_toolkit/toolkit.hxx"
#include "ADM_editor/ADM_edit.hxx"
#include "ADM_video/ADM_genvideo.hxx"
#include "ADM_filter/video_filters.h"
/*******************************************************/
#define NB_TREE 7
static int startFilter[NB_TREE];
static int max=0;
/******************************************************/
extern FILTER_ENTRY allfilters[MAX_FILTER];
extern uint32_t nb_video_filter;
extern FILTER videofilters[MAX_FILTER];
extern uint32_t nb_active_filter;
//extern ADM_Composer *video_body;

/*******************************************************/
class filtermainWindow : public QDialog
{
     Q_OBJECT

 public:
     filtermainWindow();
 //    virtual ~filtermainWindow();
     void             buildAvailableFilterList(void);
     Ui_mainFilterDialog ui;
     
     QStringList      allList[NB_TREE];
     QStringListModel allModel[NB_TREE];
     QListView        *listView[NB_TREE];
     
     
 public slots:
 private slots:
 private:
};
/**
        \fn     buildAvailableFilterList(void)
        \brief  build the internal datas needed to handle the list
*/
void filtermainWindow::buildAvailableFilterList(void)
{
  int current_tree=-1;
  char str[1024];
  
  max=0;
  for (uint32_t i = 0; i < nb_video_filter; i++)
    {
      if (allfilters[i].viewable==1)
        {
          snprintf(str,1023,"<big><b>%s</b></big>\n%s", 
                allfilters[i].name, allfilters[i].description);
  
          allList[current_tree]=allList[current_tree] << str;
          max++;
        }else 
        {
                current_tree++;
                if(current_tree>=NB_TREE) break;
                startFilter[current_tree]=i+1;
        }
    }
   
    
    ADM_assert(NB_TREE==7);
    for(int i=0;i<NB_TREE;i++)
    {
      allModel[i].setStringList(allList[i]);
    }
   
}
  
  /**
  */
filtermainWindow::filtermainWindow()     : QDialog()
 {
      buildAvailableFilterList();
      ui.setupUi(this);
      
    listView[0]=ui.listViewTransform;
    listView[1]=ui.listViewInterlacing;
    listView[2]=ui.listViewColors;
    listView[3]=ui.listViewNoise;
    listView[4]=ui.listViewSharpness;
    listView[5]=ui.listViewSubtitles;
    listView[6]=ui.listViewMisc;
    
    ui.listViewTransform->setModel(&(allModel[0]));
    ui.listViewInterlacing->setModel(&(allModel[1]));
    ui.listViewColors->setModel(&(allModel[2]));
    ui.listViewNoise->setModel(&(allModel[3]));;
    ui.listViewSharpness->setModel(&(allModel[4]));;
    ui.listViewSubtitles->setModel(&(allModel[5]));;
    ui.listViewMisc->setModel(&(allModel[6]));;
      


 }
/*******************************************************/

int GUI_handleVFilter(void);
static void updateFilterList (filtermainWindow *dialog);

/**
      \fn     GUI_handleVFilter(void)
      \brief  Show the main filter window allowing user to add/remove/configure video filters


*/
int GUI_handleVFilter(void)
{
        filtermainWindow dialog;
        if(QDialog::Accepted==dialog.exec())
        {
        }
	return 0;
}

//EOF

